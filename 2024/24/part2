#!/usr/bin/python3
import sys
import fileinput
import json
import math
import re
import copy
from datetime import datetime
import itertools

debug=True

def p(obj,timePrefix = False, newLine = True):
    if newLine:
        end = "\n"
    else:
        end = ""

    if timePrefix:
        now = datetime.now()
        print('{}: '.format(str(now.time()).split('.')[0]),end="")

    if type(obj) in [set,frozenset]:
        printableObj = list(obj)
    else:
        printableObj = obj

    if type(printableObj) in [str,int]:
        print(printableObj,end=end)
    else:
        if timePrefix:
            print('')
        print(json.dumps(printableObj, indent=2),end=end)

def pd(obj,timePrefix = False,newLine = True):
    if debug:
        p(obj,timePrefix=timePrefix,newLine=newLine)

def pdCharGrid(grid):
    if debug:
        for y in range(len(grid)):
            pd(''.join(grid[y]))

def wait():
    if debug:
        input("Press Enter to continue...")

def getInput():
    fileRows = []
    with open(sys.argv[1], 'r') as file:
        for line in file:
            fileRows.append(line.rstrip())
    
    return fileRows

# pass multiple lines
# 1 integer per line
def arrayOfIntFromList(input):
    rows = [int(c) for c in input]
    return rows

# pass multiple lines
# returns a 2 dimensional array
def arrayFromGridOfDigits(input):
    rows = []
    for line in input:
        rows.append([int(c) for c in list(line.strip())])
    return rows

# pass multiple lines
# returns a 2 dimensional array
def arrayFromGridOfSpaceSeparatedDigits(input):
    rows = []
    for line in input:
        rows.append([int(c) for c in list(line.split(" "))])
    return rows

# one line in returns an array
def arrayOfStrFromCSV(line):
    return list(line.strip().split(','))

# one line in returns an array
def arrayOfIntFromCSV(line):
    return [int(i) for i in line.strip().split(',')]
    
# one line in returns an array
def arrayOfWordsFromString(line):
    return list(line.strip().split())

def readData():
    rows = []
    for line in fileinput.input():
        # rows.append(line.strip())
        rows.append([int(c) for c in list(line.strip())])
        # [int(i) for i in line.strip().split(',')]

    return rows

def findBlankLine(lines):
    for i in range(len(lines)):
        if (lines[i].strip() == ""):
            return i
    return -1

def keyInit(dict,key,initialValue):
    if (key not in dict):
        dict[key] = initialValue

def initGrid(xSize,ySize,obj):
    grid = []
    for y in range(ySize):
        row = []
        for x in range(xSize):
            row.append(copy.deepcopy(obj))
        grid.append(row)
    return grid

def getGrid(grid,x,y,outOfBoundsObj=None):
    result = None
    if x<0 or x>=len(grid[0]) or y<0 or y>=len(grid):
        result = outOfBoundsObj
    else:
        result = grid[y][x]
    return result

def setGrid(grid,x,y,obj):
    grid[y][x] = obj

def findGrid(grid,obj):
    for y in range(len(grid)):
        for x in range(len(grid[0])):
            if getGrid(grid,x,y) == obj:
                return x,y

def setBit(value,bit):
    return value | (1<<bit)

def clearBit(value,bit):
    return value & ~(1<<bit)

def getBit(value,bit):
    return value & 1 << bit != 0 

dirList = ["^",">","v","<"]
def nextPosition(x,y,d):
    nX = x
    nY = y
    if d == "^": 
        nY -= 1
    elif d == ">":
        nX += 1
    elif d == "v":
        nY += 1
    elif d == "<":
        nX -= 1
    else:
        raise ValueError

    return nX,nY

def parseInput(input):
    data = {}
    blankIndex = findBlankLine(input)
    for line in input[:blankIndex]:
        key,value = line.split(":")
        data[key] = int(value.strip())

    for line in input[blankIndex+1:]:
        splitLine = line.split(" ")
        data[splitLine[-1]] = splitLine[:3]

    return data

def getValue(data,key):
    result = None
    if key in data:
        if isinstance(data[key], int):
            return data[key]
        else:
            formula = data[key]
            a = getValue(data,formula[0])
            b = getValue(data,formula[2])

            operator = formula[1]
            if operator == "AND":
                result = a & b
            elif operator == "XOR":
                result = a ^ b
            elif operator == "OR":
                result = a | b

            # data[key] = result

    return result

def filterKeys(data,char):
    return list(filter(lambda x: x.startswith(char) ,data.keys()))

def getNumber(data,char):
    result = 0
    for key in reversed(sorted(filterKeys(data,char))):
        value = getValue(data,key)
        # pd(f"value: {value}")
        result = (result << 1) + value
        # pd(f"result: {result}")
    return result

def bitKey(char,bit):
    return f"{char}{bit:>02d}"

def checkBit(data,bit):
    xKey = bitKey("x",bit)
    yKey = bitKey("y",bit)
    zKey = bitKey("z",bit)
    working = True
    for xBit in range(2):
        if not working:
            break
        for yBit in range(2):
            data[xKey] = xBit
            data[yKey] = yBit
            zValue = getValue(data,zKey)
            # pd(f"xKey: {xKey}  yKey: {yKey}  zKey: {zKey}")
            # pd(f"x: {xBit}  y: {yBit}  z: {zValue}  cmp: {zValue == xBit & yBit}")
            working = zValue == xBit & yBit
            if not working: 
                break

    return working
            
def checkAllBits(originalData):
    numBits = len(filterKeys(originalData,"z"))

    unmatchedBits = []
    data = copy.deepcopy(originalData)
    for i in range(numBits):
        if not checkBit(data,i):
            unmatchedBits.append(i)

    return unmatchedBits

def getDependencies(data,key):
    thisSet = set()
    # pd(f"checking: {key}")
    if isinstance(data[key], int):
        pass
    else:
        thisSet.update({key})
        formula = data[key]
        thisSet.update(getDependencies(data,formula[0]))
        thisSet.update(getDependencies(data,formula[2]))
        
    return thisSet

def getBrokenBitDependencyCount(data):
    x = getNumber(data,"x")
    y = getNumber(data,"y")
    z = getNumber(data,"z")
    # p(f"z: {z}")

    target = x & y

    xBits = math.floor(math.log2(x))+1
    yBits = math.floor(math.log2(y))+1
    zBits = math.floor(math.log2(z))+1
    targetBits = math.floor(math.log2(target))+1
    bits = max(xBits,yBits,zBits,targetBits)

    # pd(f"     x: {x:>0{bits}b}")
    # pd(f"     y: {y:>0{bits}b}")
    # pd(f"     z: {z:>0{bits}b}")
    # pd(f"target: {target:>0{bits}b}")

    # pd(f"{z==target}")
    
    brokenBits = checkAllBits(originalData)
    # pd(brokenBits)

    pd(f"broken bits: {len(brokenBits)}")

    brokenBitDependencyCount = {}
    dependencyList = set()
    for i in reversed(range(len(brokenBits))):
        thisKey = bitKey("z",brokenBits[i])
        thisSet = getDependencies(originalData,thisKey)
        brokenBitDependencyCount[thisKey] = len(thisSet)
        dependencyList.update(thisSet)
        # pd(len(thisSet))
        # pd(thisSet)
        # for key in thisSet:
        #     keyInit(brokenBitDependencyCount,key,0)
        #     brokenBitDependencyCount[key] += 1

    # for key in sorted(brokenBitDependencyCount.keys(), key=lambda x: brokenBitDependencyCount[x]):
    #     pd(f"{key}: {brokenBitDependencyCount[key]}")
    pd(f"broken dep count: {len(brokenBitDependencyCount)}")

    return brokenBitDependencyCount, dependencyList

def hasLoop(data,key=None,seenSet = None, level=0):
    # pd(f"key: {key}  level: {level}")
    if level > 100:
        raise ValueError(level)
    result = False
    if key == None:
        for startKey in data.keys():
            result = hasLoop(data,startKey, level=level+1)
            if result:
                break
    elif seenSet == None:
        if isinstance(data[key], int):
            pass
        else:
            newSet = {key}
            formula = data[key]
            result = hasLoop(data,formula[0],newSet, level=level+1) | hasLoop(data,formula[2],newSet, level=level+1)
    else:
        if key in seenSet:
            result = True
        elif isinstance(data[key], int):
            pass
        else:
            newSet = seenSet.union({key})
            formula = data[key]
            result = hasLoop(data,formula[0],newSet, level=level+1) | hasLoop(data,formula[2],newSet, level=level+1)

    return result

debug = True

sourceInput = getInput()

# data = arrayFromGridOfDigits(sourceInput)
# p(data)

originalData = parseInput(sourceInput)
# pd(data)
pd(getNumber(originalData,"z"))


# zeroData = copy.deepcopy(originalData)
# for i in range(len(filterKeys(zeroData,"x"))):
#     zeroData[bitKey("x",i)] = 0
#     zeroData[bitKey("y",i)] = 0

data = copy.deepcopy(originalData)
brokenBitDependencyCount, dependencyList = getBrokenBitDependencyCount(data)

for key in sorted(brokenBitDependencyCount.keys(), key=lambda x: brokenBitDependencyCount[x]):
    pd(f"{key}: {brokenBitDependencyCount[key]}")

swapKey1 = sorted(brokenBitDependencyCount.keys(), key=lambda x: brokenBitDependencyCount[x])[0]
for swapKey2 in dependencyList:
    if swapKey2 == swapKey1:
        continue

    data = copy.deepcopy(originalData)
    swapFormula1 = data[swapKey1]
    swapFormula2 = data[swapKey2]
    data[swapKey1] = swapFormula2
    data[swapKey2] = swapFormula1
    thisHasLoop = hasLoop(data)
    if thisHasLoop:
        pd("found loop")
    else:
        pd(f'good swap {swapKey1} and {swapKey2}')
        brokenBits, dl2 = getBrokenBitDependencyCount(data)